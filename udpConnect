#include <stdio.h>
#include <string.h>
#include <arpa/inet.h>  // Voor inet_pton()
#include <netinet/in.h> // Voor adressen
#include <sys/socket.h> // Voor sockets
#include <unistd.h>     // Voor close()
#include <stdlib.h>
#include <stdbool.h>
#include <fcntl.h>
#include <sys/select.h> // Voor fd_set en select()
#include <sys/time.h>   // Voor struct timeval

#define PORT 8888
#define PI_A_PORT 8080
#define UDPPORT 4210
#define TIMEOUT 3 // Timeout in seconden
#define Devices 2

const char *pi_a_ip = "192.168.137.40"; // Raspberry Pi A
int client_fd;                          // File descriptor voor socket (nummertje voor Wemos in print)
struct sockaddr_in serv_addr;
char wemos_ips[Devices][INET_ADDRSTRLEN] = {0};
char buffer[1024] = {0};
char RGBSend[15] = " - RGBWAARDE";
char *hello = "Hello from client\n";
char *sluiten = "End\n";
char *Led = "Led\n";
char *Knop = "Knop\n";
char *PiTest = "PiTest\n";
char *RGB = "RGB\n";
char *PiLed = "LED";
char *PiStatus = "Status";
int Waarde_Knop = 0;
int PiWaarde_Knop = 0;
int RGBWaarde = 0;
int Socket = 0;
int pi_a_socket;
int Pi_a_Led = 0;
bool Versturen = false;
ssize_t valread;

int connect_to_wemos(const char *ip)
{ // Verbind met Wemos
    int sock;
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    { // socket creation
        printf("Socket creation error\n");
        return -1;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);

    if (inet_pton(AF_INET, ip, &serv_addr.sin_addr) <= 0)
    { // ip adres toewijzen
        printf("Ongeldig adres of niet ondersteund: %s\n", ip);
        return -1;
    }

    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
    { // maak verbinding met apparaat (wemos)
        printf("Verbinding mislukt met: %s\n", ip);
        return -1;
    }

    printf("Verbonden met %d Wemos op %s\n", sock, ip);
    return sock;
}
int connect_to_device(const char *ip, int port)
{ // Verbind met Pi-a
    int sock;
    struct sockaddr_in serv_addr;

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0)
    {
        return -1;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(port);

    if (inet_pton(AF_INET, ip, &serv_addr.sin_addr) <= 0)
    {
        return -1;
    }

    // Zet socket op non-blocking mode
    int flags = fcntl(pi_a_socket, F_GETFL, 0);
    fcntl(pi_a_socket, F_SETFL, flags | O_NONBLOCK);

    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0)
    {
        fd_set fdset;
        struct timeval tv;
        FD_ZERO(&fdset);
        FD_SET(sock, &fdset);
        tv.tv_sec = TIMEOUT; // Timeout in seconden
        tv.tv_usec = 0;

        if (select(sock + 1, NULL, &fdset, NULL, &tv) > 0)
        {
            int so_error;
            socklen_t len = sizeof(so_error);
            getsockopt(sock, SOL_SOCKET, SO_ERROR, &so_error, &len);
            if (so_error == 0)
            {
                return sock;
            }
        }
        close(sock);
        return -1;
    }

    return sock;
}

int vraag_knop_status(int Socket)
{                                      // Stuur request naar wemos voor knopstatus
    memset(buffer, 0, sizeof(buffer)); // buffer leegmaken

    send(client_fd, hello, strlen(hello), 0); // stuur hello naar client_fd
    printf("%d: Hello message sent\n", Socket);

    if (Versturen)
    {
        if (Waarde_Knop == 1)
        {
            send(client_fd, Led, strlen(Led), 0);
            printf("Led message sent\n");
            Waarde_Knop = 0;
        }
        if (RGBWaarde != 0)
        {
            snprintf(RGBSend, sizeof(RGBSend), "%d - RGBWAARDE\n", RGBWaarde);
            send(client_fd, RGBSend, strlen(RGBSend), 0);
            printf("RGB message sent\n");
            RGBWaarde = 0;
        }
        // if(Pi_a_Led = 1 && )
        // Versturen = false;
    }

    memset(buffer, 0, sizeof(buffer)); // reset buffer
    send(client_fd, Knop, strlen(Knop), 0);
    // Toevoegen-aanpassen 5,D1  (Destination socket, Destination Pin)
    read(client_fd, buffer, sizeof(buffer) - 1); // lees wat er binnenkomt
    printf("%s\n", buffer);
    if (strcmp(buffer, "TRUE") == 0)
    { // kijk of wat ontvangen is vanaf Arduino IDE code == 'TRUE'
        Waarde_Knop = 1;
        Versturen = true;
    }
    memset(buffer, 0, sizeof(buffer));
    send(client_fd, PiTest, strlen(PiTest), 0);

    read(client_fd, buffer, sizeof(buffer) - 1); // zelfde maar voor PiTRUE
    printf("%s\n", buffer);
    if (strcmp(buffer, "PiTRUE") == 0)
    {
        PiWaarde_Knop = 1;
    }
    memset(buffer, 0, sizeof(buffer));

    send(client_fd, RGB, strlen(RGB), 0);

    read(client_fd, buffer, sizeof(buffer) - 1); // zelfde maar voor PiTRUE
    printf("%s\n", buffer);

    if (strcmp(buffer, "RGBFALSE") != 0)
    {
        RGBWaarde = atoi(buffer); // Converteer de string naar een integer
        Versturen = true;
    }
    memset(buffer, 0, sizeof(buffer));
}

int Pi_Connectie()
{
    if (PiWaarde_Knop == 1)
    {
        send(pi_a_socket, PiLed, strlen(PiLed), 0); // Stuur bericht dat knop is ingedrukt
        printf("Bericht LED verstuurt naar Pi-A \n");
        PiWaarde_Knop = 0;
    }
    memset(buffer, 0, sizeof(buffer));
    send(pi_a_socket, PiStatus, strlen(PiStatus), 0);
    printf("Bericht Status verstuurt naar Pi-A \n");
    valread = read(pi_a_socket, buffer, sizeof(buffer) - 1);
    buffer[valread] = '\0'; // Zorg ervoor dat de string correct wordt afgesloten
    printf("Ontvangen van Pi-A: %s\n", buffer);
    usleep(500000);
    memset(buffer, 0, sizeof(buffer));
}

int main()
{
    // UDP voorbereiding
    int udp_sockfd;
    struct sockaddr_in udp_server_addr, udp_client_addr;
    char udp_buffer[128];
    socklen_t udp_addr_len = sizeof(udp_client_addr);

    if ((udp_sockfd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
    {
        perror("UDP socket fout");
        exit(EXIT_FAILURE);
    }

    memset(&udp_server_addr, 0, sizeof(udp_server_addr));
    udp_server_addr.sin_family = AF_INET;
    udp_server_addr.sin_port = htons(UDPPORT);
    udp_server_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(udp_sockfd, (const struct sockaddr *)&udp_server_addr, sizeof(udp_server_addr)) < 0)
    {
        perror("Bind fout");
        close(udp_sockfd);
        exit(EXIT_FAILURE);
    }

    printf("Luistert naar UDP op poort %d...\n", UDPPORT);

    // Initialiseer IP-lijst leeg
    for (int i = 0; i < Devices; i++)
    {
        memset(wemos_ips[i], 0, INET_ADDRSTRLEN);
    }

    // Connectie naar Pi-A
    pi_a_socket = connect_to_device(pi_a_ip, PI_A_PORT);

    while (1)
    {
        // Ontvang UDP berichten (zoals IP van Wemos)
        memset(udp_buffer, 0, sizeof(udp_buffer));
        int bytes = recvfrom(udp_sockfd, udp_buffer, sizeof(udp_buffer) - 1, 0, (struct sockaddr *)&udp_client_addr, &udp_addr_len);
        printf("Ontvangen: ", udp_buffer);

        if (bytes > 0)
        {
            int index = -1;
            if (strncmp(udp_buffer, "WEMOS", 5) == 0)
            {
                index = udp_buffer[5] - '1'; // '1' → 0, '2' → 1
                if (index >= 0 && index < Devices)
                {
                    // Zoek het dubbelepunt in de string
                    char *colon = strchr(udp_buffer, ':');
                    if (colon != NULL && strlen(colon + 1) < INET_ADDRSTRLEN)
                    {
                        strncpy(wemos_ips[index], colon + 1, INET_ADDRSTRLEN);
                        printf("WEMOS%d IP opgeslagen: %s\n", index + 1, wemos_ips[index]);
                    }
                }
            }
        }

        // Controleer of alle IP's zijn ontvangen
        bool all_received = true;
        for (int i = 0; i < Devices; i++)
        {
            if (strlen(wemos_ips[i]) == 0)
            {
                all_received = false;
                break;
            }
        }

        if (all_received)
        {
            Pi_Connectie();
            if (Socket < Devices)
            {
                printf("%d\n", Socket);
                client_fd = connect_to_wemos(wemos_ips[Socket]);
                sleep(2);
                Socket++;
            }

            for (int i = 0; i < Devices; i++)
            {
                client_fd = i + 4;
                vraag_knop_status(i);
            }
        }
        else
        {
            printf("Wacht op alle Wemos apparaten...\n");
        }

        sleep(1);
    }

    close(udp_sockfd);
    return 0;
}
